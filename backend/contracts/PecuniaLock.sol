//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";
import "./verifier.sol";
import "hardhat/console.sol";
import "./mock/HeirToken.sol";

contract PecuniaLock is Context, IERC721Receiver, KeeperCompatibleInterface {
    using Counters for Counters.Counter;
    //include enum for will state

    // Observed gas is 92k + 8k buffer
    uint256 private constant MIN_GAS_FOR_TRANSFER = 100_000;

    uint256 public gb;
    uint256 public gb1;
    uint256 public gb2;

    Verifier verifier;

    HeirToken public heirToken;

    event Register(bytes32 indexed boxhash, address indexed owner);

    event RechargeMatic(
        address indexed sender,
        address indexed heirAddress,
        uint256 amount
    );

    event RechargeNft(
        address indexed sender,
        address indexed heirAddress,
        address nftAddress
    );

    event WithdrawSigned(
        address indexed owner,
        address indexed to,
        uint256 amount
    );

    event BoxCanceled(address indexed owner);

    event FundsAdded(uint256 amountAdded, uint256 newBalance, address sender);

    event FundsTransferred(uint256 amount, address heir);

    bytes32[] private boxHashes;

    ///Prevent Re-Entracy Attack
    bool private locked;

    struct SafeBox {
        bytes32 boxhash;
        address user;
        address nftAddress;
        uint256 heirToInterval;
        uint256 lastTimeStamp;
        uint256 totalDeposit;
        address[] addresss;
        mapping(address => uint256) heirToBalance;
        mapping(address => uint256) heirToTokenid;
        mapping(address => bool) withdrawSigned;
        mapping(address => uint256[]) heirToNfts;
        mapping(address => bool) isActive;
    }

    mapping(bytes32 => SafeBox) public boxhash2safebox;

    mapping(address => bytes32) public user2boxhash;

    mapping(uint256 => bool) public usedProof;

    mapping(uint256 => bool) public isHeirTokenValid;

    constructor() {
        verifier = new Verifier();
        heirToken = new HeirToken();
        heirToken.mint(address(this), "Genesis Token");
        gb = 0;
        gb1 = 0;
        gb2 = 0;
    }

    // function balanceOf(address user, address[] memory tokenAddrs) public view returns(uint[] memory bals) {
    //     bytes32 boxhash = user2boxhash[user];
    //     SafeBox storage box = boxhash2safebox[boxhash];
    //     bals = new uint[](tokenAddrs.length);
    //     for (uint i=0; i<tokenAddrs.length; i++) {
    //         address tokenAddr = tokenAddrs[i];
    //         bals[i] = box.balance[tokenAddr];
    //     }
    // }

    /**
     * @notice Register the user
     * @param boxhash the hash of box
     * @param proof zero-knowledge proof generated by the hash of password
     * @param pswHash password hash
     * @param allHash hash of amount and password
     * @param interval time after which will amount is transffered
     */
    function register(
        bytes32 boxhash,
        uint256[8] memory proof,
        uint256 pswHash,
        uint256 allHash,
        uint256 interval
    ) public {
        SafeBox storage box = boxhash2safebox[boxhash];

        require(
            user2boxhash[_msgSender()] == bytes32(0),
            "PecuniaLock::register: one user one safebox"
        );
        require(
            box.boxhash == bytes32(0),
            "PecuniaLock::register: boxhash has been registered"
        );
        require(
            keccak256(abi.encodePacked(pswHash, _msgSender())) == boxhash,
            "PecuniaLock::register: boxhash error"
        );
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [pswHash, 0, allHash]
            ),
            "PecuniaLock::register: verifyProof fail"
        );
        require(interval > 0, "PecuniaLock::register: interval cannot be zero");

        box.boxhash = boxhash;
        box.user = _msgSender();
        box.heirToInterval = interval;
        box.lastTimeStamp = block.timestamp;

        user2boxhash[box.user] = boxhash;
        boxHashes.push(boxhash);
        emit Register(boxhash, box.user);
    }

    /**
     * @notice assign funds and nfts to heir using address of owner
     * @param boxOwner address of box owner
     * @param heirAddr address of the heir
     * @param nftAddr address of the nft
     * @param nftTokenIds token ids
     * @return tokenId of the HEIR NFT
     */
    function rechargeWithAddress(
        address boxOwner,
        address heirAddr,
        address nftAddr,
        uint256[] memory nftTokenIds
    ) external payable returns (uint256 tokenId) {
        require(
            msg.sender == boxOwner,
            "PecuniaLock::rechargeWithAddress: only owner can assign funds to heirs"
        );
        require(
            heirAddr != address(0),
            "PecuniaLock::rechargeWithAddress: Heir cannot be 0 address"
        );
        require(
            boxOwner != heirAddr,
            "PecuniaLock::rechargeWithAddress: Owner cannot be heir"
        );
        uint256 amount = msg.value;
        tokenId = _rechargeWithAddress(
            boxOwner,
            heirAddr,
            amount,
            nftAddr,
            nftTokenIds
        );
        return tokenId;
    }

    /**
     * @notice internal funciton to assign funds and nfts to heir using address of owner
     * @param boxOwner address of box owner
     * @param heirAddr address of the heir
     * @param nftAddr address of the nft
     * @param nftTokenIds token ids
     * @return tokenId of the HEIR NFT
     */
    function _rechargeWithAddress(
        address boxOwner,
        address heirAddr,
        uint256 amount,
        address nftAddr,
        uint256[] memory nftTokenIds
    ) internal returns (uint256 tokenId) {
        bytes32 boxhash = user2boxhash[boxOwner];
        require(
            boxhash != bytes32(0),
            "PecuniaLock::rechargeWithAddress: safebox not register yet"
        );

        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            box.isActive[heirAddr] == false,
            "PecuniaLock::rechargeWithAddress: Amount already assigned to heir"
        );
        require(
            amount > 0 || (nftAddr != address(0) && nftTokenIds.length >= 0),
            "PecuniaLock::rechargeWithAddress: Both amount and NFT cannot be empty"
        );

        if (amount > 0) {
            _rechargeOfMatic(boxOwner, boxhash, heirAddr, amount);
            console.log("amount deposited=", amount);
        }
        if (nftAddr != address(0) && nftTokenIds.length >= 0) {
            if (box.nftAddress == address(0)) {
                box.nftAddress = nftAddr;
            }
            _rechargeOfNft(boxOwner, boxhash, heirAddr, nftAddr, nftTokenIds);
            console.log("NFTs deposited");
        }
        box.isActive[heirAddr] = true;
        // TODO: SOULBOUND NFTS
        tokenId = heirToken.mint(heirAddr, "");
        box.heirToTokenid[heirAddr] = tokenId;
        box.addresss.push(heirAddr);

        return tokenId;
    }

    /**
     * @notice assign funds to heir using boxhash
     * @param boxOwner address of box owner
     * @param boxhash the hash of box
     * @param heirAddr address of the heir
     * @param amount amount of matic assigned to heir
     */
    function _rechargeOfMatic(
        address boxOwner,
        bytes32 boxhash,
        address heirAddr,
        uint256 amount
    ) internal {
        SafeBox storage box = boxhash2safebox[boxhash];
        box.heirToBalance[heirAddr] += amount;
        box.totalDeposit += amount;
        emit RechargeMatic(boxOwner, heirAddr, amount);
    }

    /**
     * @notice assign nfts to heir using boxhash
     * @param boxOwner address of box owner
     * @param boxhash the hash of box
     * @param heirAddr address of the heir
     * @param nftAddr address of nft
     * @param nftTokenIds token ids
     */
    function _rechargeOfNft(
        address boxOwner,
        bytes32 boxhash,
        address heirAddr,
        address nftAddr,
        uint256[] memory nftTokenIds
    ) internal {
        SafeBox storage box = boxhash2safebox[boxhash];

        for (uint256 i = 0; i < nftTokenIds.length; i++) {
            require(
                IERC721(nftAddr).getApproved(nftTokenIds[i]) == address(this),
                "PecuniaLock::_rechargeOfNft: NFT approval not set"
            );
            IERC721(nftAddr).safeTransferFrom(
                boxOwner,
                address(this),
                nftTokenIds[i]
            );
            box.heirToNfts[heirAddr].push(nftTokenIds[i]);
        }
        emit RechargeNft(boxOwner, heirAddr, nftAddr);
    }

    /**
     * @notice heir needs to sign the will before the chainlink keepers send amount to his/her address
     * @param proof zero-knowledge proof genereated using password
     * @param pswHash hash of the password
     * @param allHash hash of the password and amount
     * @param boxOwner address of box owner
     */
    function withdrawSignature(
        uint256[8] memory proof,
        uint256 pswHash,
        uint256 allHash,
        address boxOwner
    ) public {
        address heir = msg.sender;
        require(
            heir != boxOwner,
            "PecuniaLock::withdrawSignature: Owner cannot withdraw amount"
        );
        require(
            !usedProof[proof[0]],
            "PecuniaLock::withdrawSignature: proof used"
        );

        bytes32 boxhash = user2boxhash[boxOwner];
        require(
            keccak256(abi.encodePacked(pswHash, boxOwner)) == boxhash,
            "PecuniaLock::withdrawSignature: pswHash error"
        );

        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            box.boxhash != bytes32(0),
            "PecuniaLock::withdrawSignature: safebox not register yet"
        );

        require(
            box.heirToTokenid[heir] > 0,
            "PecuniaLock::withdrawSignature: Heir not valid"
        );

        require(
            box.isActive[heir],
            "PecuniaLock::withdrawSignature: Heir has already taken amount or will is canceled"
        );

        uint256 amount = box.heirToBalance[heir];
        console.log("amount withdrawn", amount);

        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [pswHash, amount, allHash]
            ),
            "PecuniaLock::withdraw: verifyProof fail"
        );
        uint256 tokenId = box.heirToTokenid[heir];
        require(tokenId > 0, "PecuniaLock::withdraw: token id invalid");
        require(
            heirToken.getApproved(tokenId) == address(this),
            "Approval for NFT Token not given"
        );

        heirToken.burn(tokenId);
        usedProof[proof[0]] = true;

        box.withdrawSigned[heir] = true;
        emit WithdrawSigned(box.user, heir, amount);
    }

    /**
     * @notice cancels the will and transfer all the assets back to owner and emits
     */
    function cancelBoxAndTransferFundsToOwner() external {
        address boxOwner = msg.sender;
        bytes32 boxhash = user2boxhash[boxOwner];

        require(
            boxhash != bytes32(0),
            "PecuniaLock::cancelBoxAndTransferFundsToOwner: safebox not register yet"
        );
        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            msg.sender == box.user,
            "PecuniaLock::cancelBoxAndTransferFundsToOwner: only owner can cancel this"
        );
        address[] memory heirAddresses = box.addresss;

        // Transfer Matic
        uint256 totalDeposit = box.totalDeposit;
        if (totalDeposit > 0) {
            box.totalDeposit = 0; //prevent re-entracy
            safeTransferETH(boxOwner, totalDeposit);
        }

        //Transfer Nfts
        for (uint256 i = 0; i < heirAddresses.length; i++) {
            if (box.isActive[heirAddresses[i]]) {
                if (box.heirToNfts[heirAddresses[i]].length > 0) {
                    for (
                        uint256 j = 0;
                        j < box.heirToNfts[heirAddresses[i]].length;
                        j++
                    ) {
                        IERC721(box.nftAddress).safeTransferFrom(
                            address(this),
                            boxOwner,
                            box.heirToNfts[heirAddresses[i]][j]
                        );
                        console.log("Owner NFTs trasnffered back to owner");
                    }
                }
                box.isActive[heirAddresses[i]] = false;
            }
        }
        delete (boxhash2safebox[boxhash]);
        emit BoxCanceled(boxOwner);
    }

    function safeTransferETH(address to, uint256 value) internal {
        require(
            address(this).balance >= value,
            "PecuniaLock::safeTransferETH: Insufficient amount"
        );
        require(!locked, "PecuniaLock::safeTransferETH: Re-Entracy");
        locked = true;
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(
            success,
            "TransferHelper::safeTransferETH: ETH transfer failed"
        );
        locked = false;
    }

    // Chainlink Keeper Functions
    /**
     * @notice Get the all the wills/boxes which have matured
     * @return array of boxes/wills which have matured
     */
    function getMaturedBoxes() public view returns (bytes32[] memory) {
        bytes32[] memory t_boxHashes = new bytes32[](boxHashes.length);
        uint256 count = 0;
        for (uint256 i = 0; i < boxHashes.length; i++) {
            bytes32 bh = boxHashes[i];
            SafeBox storage sb = boxhash2safebox[bh];
            bool boxAdded = false;
            for (uint256 j = 0; j < (sb.addresss).length; j++) {
                if (
                    block.timestamp - sb.lastTimeStamp >= sb.heirToInterval && // time is up
                    sb.isActive[sb.addresss[j]] && // heir has already not received loan amount
                    sb.withdrawSigned[sb.addresss[j]] && //heir has completed withdraw signature
                    boxAdded == false //will or box is aready not added
                ) {
                    t_boxHashes[count] = bh;
                    count++;
                    boxAdded = true;
                }
            }
        }
        if (count != boxHashes.length) {
            assembly {
                mstore(t_boxHashes, count)
            }
        }
        return t_boxHashes;
    }

    /**
     * @notice Transfer amount to heir if he has signed the will and will has matured
     * @param maturedBoxes Wills/Boxes which have matured
     */
    function _transferAmountToHeirs(bytes32[] memory maturedBoxes) internal {
        gb1 = gb1 + 1;
        for (uint256 i = 0; i < maturedBoxes.length; i++) {
            // SafeBox storage sb = boxhash2safebox[maturedBoxes[i]];
            address[] memory ad = boxhash2safebox[maturedBoxes[i]].addresss;
            for (uint256 j = 0; j < ad.length; j++) {
                if (
                    boxhash2safebox[maturedBoxes[i]].withdrawSigned[ad[j]] &&
                    block.timestamp -
                        boxhash2safebox[maturedBoxes[i]].lastTimeStamp >=
                    boxhash2safebox[maturedBoxes[i]].heirToInterval &&
                    boxhash2safebox[maturedBoxes[i]].isActive[ad[j]]
                ) {
                    uint256 amount = boxhash2safebox[maturedBoxes[i]]
                        .heirToBalance[ad[j]];
                    if (amount > 0) {
                        console.log("paying amt, to:", amount, ad[j]);
                        bool success = payable(ad[j]).send(amount);
                        if (success) {
                            boxhash2safebox[maturedBoxes[i]].heirToBalance[
                                ad[j]
                            ] = 0;
                            console.log("Funds Transferred");
                            emit FundsTransferred(amount, ad[j]);
                        }
                    }
                    if (
                        boxhash2safebox[maturedBoxes[i]].nftAddress !=
                        address(0)
                    ) {
                        for (
                            uint256 k = 0;
                            k <
                            boxhash2safebox[maturedBoxes[i]]
                                .heirToNfts[ad[j]]
                                .length;
                            k++
                        ) {
                            IERC721(boxhash2safebox[maturedBoxes[i]].nftAddress)
                                .safeTransferFrom(
                                    address(this),
                                    ad[j],
                                    boxhash2safebox[maturedBoxes[i]].heirToNfts[
                                        ad[j]
                                    ][k]
                                );
                            console.log("Owner NFT transffered");
                        }
                    }
                    boxhash2safebox[maturedBoxes[i]].isActive[ad[j]] = false;
                    boxhash2safebox[maturedBoxes[i]].withdrawSigned[
                        ad[j]
                    ] = false;
                    // TODO add else and gas optimization cond
                }
                if (gasleft() < MIN_GAS_FOR_TRANSFER) {
                    return;
                }
            }
        }
        gb2 = gb2 + 1;
    }

    /**
     * @notice chainlink keeper function which checks which boxes have matured
     * @return upkeepNeeded :bool value which tells if some will/box has matured
     * @return performData :bytes encoded data of matured will/box
     */
    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        bytes32[] memory boxes = getMaturedBoxes();
        upkeepNeeded = boxes.length > 0;
        performData = abi.encode(boxes);
        return (upkeepNeeded, performData);
    }

    /**
     * @notice chainlink keeper function which transfer the amounts to heirs if any will/box has matured
     * @param performData bytes encoded data of matured will/box
     */
    function performUpkeep(bytes calldata performData) external override {
        gb = gb + 1;
        bytes32[] memory maturedBoxes = abi.decode(performData, (bytes32[]));
        _transferAmountToHeirs(maturedBoxes);
    }

    // Chainlink keeper funciton ends

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }

    // Public Getter Setter Funcitons

    /**
     * @notice get heir amount from owner add
     * @param owner owner address
     * @param heir heir address
     * @return amount
     */
    function getHeirAmountFromOwner(address owner, address heir)
        public
        view
        returns (uint256)
    {
        return boxhash2safebox[user2boxhash[owner]].heirToBalance[heir];
    }

    /**
     * @notice get heir amount from box hash
     * @param boxhash boxhash
     * @param heir heir address
     * @return amount
     */
    function getHeirAmountFromOwner(bytes32 boxhash, address heir)
        public
        view
        returns (uint256)
    {
        return boxhash2safebox[boxhash].heirToBalance[heir];
    }

    /**
     * @notice get if heir has signed the will/box
     * @param owner owner address
     * @param heir heir address
     * @return bool
     */
    function getHeirWithdrawCounterFromOwner(address owner, address heir)
        public
        view
        returns (bool)
    {
        return boxhash2safebox[user2boxhash[owner]].withdrawSigned[heir];
    }

    /**
     * @notice get if heir has signed the will/box from boxhash
     * @param boxhash boxhash
     * @param heir heir address
     * @return bool
     */
    function getHeirWithdrawCounterFromBoxHash(bytes32 boxhash, address heir)
        public
        view
        returns (bool)
    {
        return boxhash2safebox[boxhash].withdrawSigned[heir];
    }

    /**
     * @notice get all the registered heirs array
     */
    function getSafeBoxHeirsFromOwner(address owner)
        public
        view
        returns (address[] memory)
    {
        return boxhash2safebox[user2boxhash[owner]].addresss;
    }

    /**
     * @notice get all the registered heirs array from box hash
     */
    function getSafeBoxHeirsFromBoxHash(bytes32 boxhash)
        public
        view
        returns (address[] memory)
    {
        return boxhash2safebox[boxhash].addresss;
    }

    /**
     * @notice get safe box details
     */
    function getSafeBoxDetailsFromOwner(address owner)
        public
        view
        returns (
            bytes32,
            uint256,
            uint256
        )
    {
        return (
            boxhash2safebox[user2boxhash[owner]].boxhash,
            boxhash2safebox[user2boxhash[owner]].heirToInterval,
            boxhash2safebox[user2boxhash[owner]].lastTimeStamp
        );
    }

    /**
     * @notice get safe box details from boxhash
     */
    function getSafeBoxDetailsFromBoxHash(bytes32 boxhash)
        public
        view
        returns (
            bytes32,
            uint256,
            uint256
        )
    {
        return (
            boxhash2safebox[boxhash].boxhash,
            boxhash2safebox[boxhash].heirToInterval,
            boxhash2safebox[boxhash].lastTimeStamp
        );
    }

    /**
     * @notice get time left for the will/box to expire/mature
     */
    function getTimeLeftFromOwner(address owner) public view returns (uint256) {
        return (block.timestamp -
            boxhash2safebox[user2boxhash[owner]].lastTimeStamp);
    }

    /**
     * @notice recieve funds
     */
    receive() external payable {
        emit FundsAdded(msg.value, address(this).balance, msg.sender);
    }
}
